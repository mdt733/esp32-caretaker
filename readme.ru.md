# Управление роботом ESP32-CAM с потоковой трансляцией видео

## Обзор

Этот проект реализует робота с дистанционным управлением на основе платы ESP32-CAM. Проект обеспечивает потоковую трансляцию видео с ESP32-CAM в режиме реального времени и позволяет управлять двумя моторами в обоих направлениях. Роботом можно управлять через веб-интерфейс с использованием либо виртуального джойстика, либо ползунков для задания скорости моторов. Кроме того, веб-интерфейс предоставляет элементы управления для настройки качества видео и переключения встроенного светодиода. Также собирается статистика использования задач для мониторинга производительности системы.

## Функциональность

*   **Потоковая трансляция видео:** Передача видео с ESP32-CAM в веб-браузер в режиме реального времени.
*   **Дуплексное управление моторами:** Управление двумя моторами с помощью драйвера моторов L298N, обеспечивающее движение вперед/назад и повороты.
*   **Веб-интерфейс для управления:** Удобный веб-интерфейс для управления роботом с любого устройства с веб-браузером.
*   **Режимы управления с джойстиком и ползунками:** Два режима управления – виртуальный джойстик для интуитивного управления и ползунки для индивидуальной регулировки скорости моторов.
*   **Регулируемое качество видео:** Возможность переключения между различными разрешениями видео (QQVGA, QCIF, HQVGA, QVGA, CIF, HVGA, VGA, SVGA, XGA, HD, SXGA, UXGA) для оптимизации использования пропускной способности или повышения четкости.
*   **Управление встроенным светодиодом:** Контроль яркости встроенного светодиода ESP32-CAM с точной регулировкой от 0 до 100%.
*   **Поддержка Bluetooth-контроллера:** Возможность подключения физического Bluetooth-джойстика (например, ExpressLRS Joystick) для более точного управления.
*   **Статистика использования задач:** Мониторинг и отображение загрузки процессора разными задачами на ESP32 для анализа производительности и оптимизации.
*   **WiFi подключение:** Подключение к WiFi сети для удаленного управления и потоковой трансляции.
*   **Встроенный веб-интерфейс:** HTML-интерфейс встраивается непосредственно в прошивку в виде C-заголовочного файла во время сборки, устраняя необходимость в отдельной файловой системе.

## Как это работает

Проект построен на фреймворке Arduino для ESP32 и использует FreeRTOS для организации многозадачности. Ниже приводится описание основных компонентов и их взаимодействий:

1.  **Инициализация камеры (`camera_config.h`, `src/main.cpp`):**
    *   Инициализирует модуль ESP32-CAM с использованием библиотеки `esp_camera.h`.
    *   Настраивает параметры камеры, такие как разрешение (`FRAMESIZE_QVGA`, `FRAMESIZE_VGA`, `FRAMESIZE_SVGA`). Более низкое разрешение снижает использование пропускной способности.
    *   Настраивает необходимые пины GPIO для связи с камерой, как определено в файле `config.h`.
2.  **Управление моторами (`include/motor_control.h`, `src/motor_control.cpp`):**
    *   Задает пины для управления моторами с использованием драйвера L298N и конфигураций PWM каналов.
    *   Реализует функции для инициализации моторов (`initMotors`), задания скорости моторов (`setMotorSpeed`) и обработки сигналов управления от джойстика и ползунков.
    *   Включает логику для игнорирования небольших отклонений (dead zone), минимальной мощности для запуска мотора и порогов поворота.
    *   Использует `ledcWrite` для управления скоростью моторов через PWM.
3.  **Управление WiFi (`include/wifi_manager.h`, `src/wifi_manager.cpp`):**
    *   Обеспечивает подключение к WiFi и восстановление соединения.
    *   Считывает SSID и пароль WiFi из переменных окружения, определенных в файле `.env`.
    *   Предоставляет функции для инициализации WiFi (`initWiFi`) и поддержания стабильного соединения (`ensureWiFiConnection`).
4.  **HTTP сервер (`include/http_server_task.h`, `src/http_server_task.cpp`):**
    *   Запускается как задача FreeRTOS (`TaskHttpServer`) на ядре 1.
    *   Использует библиотеку `WebServer.h` для обработки HTTP запросов.
    *   Отдает веб-интерфейс из встроенного константного массива `INDEX_HTML` в файле `html_content.h`.
    *   Обрабатывает следующие эндпоинты:
        *   `/` : Возвращает основную HTML страницу из встроенного массива.
        *   `/led?brightness={0-100}` : Управляет яркостью светодиода с точной регулировкой.
        *   `/quality?resolution={RESOLUTION}` : Переключает разрешение видео (например, QVGA, VGA, HD).
        *   `/control` (POST): Принимает команды управления моторами в формате JSON от веб-интерфейса для режимов с джойстиком и ползунками.
        *   `/stream` : Запускает трансляцию видео.
        *   `/stopstream` : Останавливает трансляцию видео.
        *   `/bt?state={on|off}` : Включает или отключает поддержку Bluetooth-контроллера.
        *   `/bt/status` : Возвращает текущий статус подключения Bluetooth.
5.  **Потоковая трансляция видео (`include/stream_task.h`, `src/stream_task.cpp`, `include/stream_constants.h`):**
    *   Запускается как задача FreeRTOS (`streamTask`) на ядре 0.
    *   Захватывает кадры с ESP32-CAM с помощью функции `esp_camera_fb_get()`.
    *   Кодирует кадры в формате MJPEG и передает их клиенту через HTTP с использованием многочастных ответов.
    *   Использует константы, определенные в `stream_constants.h` для настройки трансляции (размеры буфера, приоритет задачи, типы контента).
    *   Реализует функции для запуска (`handleStartStream`), остановки (`handleStopStream`) и управления трансляцией.
6.  **Генерация веб-интерфейса (`scripts/pre_build_script.py`, `scripts/generate_html.py`):**
    *   Во время процесса сборки HTML-файл из `data/html/index.html` преобразуется в C-заголовочный файл.
    *   Скрипт создает C-заголовочный файл `include/html_content.h` с HTML-содержимым, встроенным в виде строковой константы.
    *   Этот подход устраняет необходимость в отдельной файловой системе и уменьшает потребление памяти.
    *   Конфигурация для этого процесса указана в `platformio.ini` с переменными `custom_html_source` и `custom_html_header`.
7. **Bluetooth-управление (`include/bluetooth_task.h`, `src/bluetooth_task.cpp`):**
    *   Реализует поддержку Bluetooth Low Energy (BLE) с использованием библиотеки NimBLE.
    *   Выполняет сканирование и подключение к конкретным Bluetooth-контроллерам (например, ExpressLRS Joystick).
    *   Обрабатывает входные данные от Bluetooth-джойстика и преобразует их в команды управления моторами.
    *   Предоставляет информацию о статусе и управление подключением через веб-интерфейс.
8.  **Статистика задач (`include/task_stats.h`, `src/log_task.cpp`):**
    *   Сбор и отображение статистики работы задач FreeRTOS.
    *   Задача `TaskLog` запускается на ядре 1 и периодически выводит статистику загрузки процессора с помощью `vTaskGetRunTimeStats` в последовательный монитор.
    *   Это помогает отслеживать загрузку процессора и выявлять потенциальные узкие места в производительности.
9.  **Конфигурационные файлы (`config.h`, `.env`, `platformio.ini`, `sdkconfig.defaults`):**
    *   `config.h`: Определяет аппаратные настройки (параметры камеры, пин светодиода, параметры управления моторами, настройки трансляции).
    *   `.env`: Хранит конфиденциальные данные (SSID и пароль WiFi), которые подставляются в процессе сборки.
    *   `platformio.ini`: Конфигурационный файл для PlatformIO, задающий платформу, плату, фреймворк, флаги сборки, библиотеки и преобразование HTML в заголовочный файл.
    *   `sdkconfig.defaults`: Конфигурационные значения ESP-IDF, позволяющие собирать статистику работы FreeRTOS.

## Установка

Следуйте этим шагам для настройки и запуска проекта:

### Требования

1.  **PlatformIO IDE:** Установите PlatformIO IDE в VS Code. Инструкции по установке доступны на [сайте PlatformIO](https://platformio.org/install/ide?install=vscode).
2.  **Плата ESP32-CAM:** Вам понадобится модуль ESP32-CAM.
3.  **Преобразователь USB в последовательный порт:** Для загрузки кода на ESP32-CAM понадобится преобразователь USB в последовательный порт (например, адаптер FTDI). Убедитесь, что он поддерживает уровни логических сигналов 3.3V.
4.  **Драйвер моторов L298N (по желанию):** Если вы планируете управлять моторами, потребуется драйвер моторов L298N и два двигателя постоянного тока.
5.  **Bluetooth-контроллер (по желанию):** Для физического управления можно использовать джойстик ExpressLRS или аналогичный BLE-джойстик.

### Настройка проекта

1.  **Клонируйте репозиторий:** Склонируйте репозиторий проекта на свой локальный компьютер.
2.  **Откройте проект в PlatformIO:** Откройте склонированную папку проекта в VS Code с установленным PlatformIO IDE.
3.  **Настройка учетных данных WiFi:**
    *   Создайте файл с именем `.env` в корневой директории проекта.
    *   Добавьте в файл следующие строки, заменив `YOUR_WIFI_SSID` и `YOUR_WIFI_PASSWORD` на реальные данные вашей WiFi сети:

    ```
    WIFI_SSID="YOUR_WIFI_SSID"
    WIFI_PASSWORD="YOUR_WIFI_PASSWORD"
    ```

4.  **Конфигурация PlatformIO (`platformio.ini`):**
    *   Убедитесь, что файл `platformio.ini` настроен для окружения `esp32cam`.
    *   Флаг сборки `build_flags` в `platformio.ini` использует bash-скрипт `generate_build_flags.sh` для подстановки учетных данных WiFi из файла `.env` в процесс сборки. Убедитесь, что у скрипта есть права на выполнение (`chmod +x generate_build_flags.sh`).
    *   Конфигурация также указывает исходный HTML-файл и целевой заголовочный файл для преобразования веб-интерфейса.

5.  **Сборка прошивки:** В PlatformIO IDE соберите проект, нажав на иконку PlatformIO в боковой панели, затем выберите "Project Tasks" -> "esp32cam" -> "Build".
    *   Во время процесса сборки HTML-файл автоматически преобразуется в C-заголовочный файл с использованием Python-скрипта в `scripts/pre_build_script.py`.

### Загрузка прошивки

1.  **Подключите ESP32-CAM:** Подключите ESP32-CAM к преобразователю USB в последовательный порт для прошивки. **Важно:** Возможно, потребуется соединить пин GPIO0 с GND во время прошивки, чтобы перевести ESP32 в режим программирования. Подробности см. в документации к ESP32-CAM.
2.  **Загрузите прошивку:** В PlatformIO IDE загрузите прошивку, нажав "Upload" в "Project Tasks" -> "esp32cam".

### Подключение моторов (по желанию)

Если вы планируете управлять моторами, подключите драйвер моторов L298N к ESP32-CAM следующим образом, используя пины, определенные в файле `motor_control.h`:

*   **Пины ESP32-CAM** | **Пины L298N**
    ------- | --------
    GPIO14 (MOTOR_LEFT_IN1) | IN1
    GPIO15 (MOTOR_LEFT_IN2) | IN2
    GPIO13 (MOTOR_RIGHT_IN1) | IN3
    GPIO12 (MOTOR_RIGHT_IN2) | IN4
    GND | GND (логическая часть L298N)
    5V или Vin | VCC (логическая часть L298N)
    Питание ESP32-CAM (5V или Vin) | Питание моторов L298N (12V или согласно требованиям моторов)
    GND | GND (питание моторов L298N)
    Выход мотора 1 | Мотор 1
    Выход мотора 2 | Мотор 2

    **Примечание:** Убедитесь, что вы подаете достаточное питание для драйвера L298N, которое может отличаться от питания ESP32-CAM, если это необходимо.

## Конфигурация

Вы можете настроить различные аспекты проекта, изменяя конфигурационные файлы:

### `config.h`

*   **Параметры камеры:**
    *   `CAMERA_FRAMESIZE`: Установите разрешение видео (например, `FRAMESIZE_QVGA`, `FRAMESIZE_VGA`, `FRAMESIZE_SVGA`). Более низкое разрешение снижает использование пропускной способности.
    *   `CAMERA_JPEG_QUALITY`: Настройте качество JPEG (от 0 до 63, где меньшее значение означает лучшее качество, но больший размер файла).
    *   `CAMERA_XCLK_FREQ`: Частота тактирования камеры.
    *   `CAMERA_PIXEL_FORMAT`: Формат пикселей, обычно `PIXFORMAT_JPEG`.
    *   `CAMERA_FB_COUNT`: Количество буферов для кадров.

*   **Параметры светодиода:**
    *   `LED_PIN`: Пин GPIO для подключения светодиода.
    *   `LED_CHANNEL`, `LED_RESOLUTION`, `LED_FREQUENCY`: Параметры PWM для управления светодиодом.
    *   `LED_BRIGHT_OFF`, `LED_BRIGHT_MID`, `LED_BRIGHT_HIGH`: Значения PWM для различных уровней яркости светодиода.

*   **Параметры трансляции:**
    *   `STR_MAX_FRAME_SIZE`: Максимальный размер кадра для трансляции.
    *   `STR_STREAM_TASK_STACK_SIZE`: Размер стека для задачи трансляции.
    *   `STR_STREAM_TASK_PRIORITY`: Приоритет задачи трансляции.
    *   `STR_STREAM_TASK_CORE`: Ядро, на котором запускается задача трансляции (0 или 1).
    *   `STR_STREAM_DELAY_MS`: Задержка между кадрами в задаче трансляции.

### `motor_control.h`

*   **Параметры управления моторами:**
    *   `MOTOR_DEADZONE`: Зона мертвых зон для сигналов от джойстика/ползунков для игнорирования небольших движений.
    *   `MOTOR_MIN_POWER`: Минимальное значение PWM для запуска мотора. Измените это значение, если вашим моторам требуется большее стартовое напряжение.
    *   `MOTOR_MAX_POWER`: Максимальное значение PWM для моторов (обычно 255 для 8-битной точности).
    *   `MOTOR_TURN_THRESHOLD`: Порог по оси X джойстика для активации поворота на месте.

### `joystick_config.h`

*   **Параметры Bluetooth-джойстика:**
    *   `JOYSTICK_DEVICE_NAME`: Имя Bluetooth-джойстика для подключения (по умолчанию "ExpressLRS Joystick").
    *   `BLE_SCAN_TIME`: Продолжительность сканирования Bluetooth-устройств (в секундах).
    *   `BLE_RESCAN_INTERVAL`: Частота повторного сканирования при отсутствии устройства (в миллисекундах).
    *   Различные параметры калибровки осей джойстика для соответствия вашему конкретному контроллеру.

### `.env`

*   **Учетные данные WiFi:**
    *   `WIFI_SSID`: SSID вашей сети WiFi.
    *   `WIFI_PASSWORD`: Пароль вашей сети WiFi.

### `sdkconfig.defaults`

*   **Конфигурация FreeRTOS:**
    *   `CONFIG_FREERTOS_GENERATE_RUN_TIME_STATS`: Включает сбор статистики работы FreeRTOS.
    *   `CONFIG_FREERTOS_USE_STATS_FORMATTING_FUNCTIONS`: Включает функции форматирования статистики.
    *   `CONFIG_FREERTOS_RUN_TIME_COUNTER_TYPE`: Определяет тип счётчика времени выполнения.

### Настройка веб-интерфейса

Для изменения веб-интерфейса:
1. Отредактируйте HTML-файл в `data/html/index.html`
2. Изменения будут автоматически включены в прошивку при следующей сборке
3. Нет необходимости загружать образы файловой системы, так как HTML встроен в прошивку

## Использование

1.  **Включите питание:** Включите плату ESP32-CAM. Убедитесь, что она подключена к вашей WiFi сети.
2.  **Получите IP-адрес:** Откройте последовательный монитор в PlatformIO (или в Arduino IDE) и проверьте вывод. После подключения к WiFi ESP32-CAM выведет свой IP-адрес.
3.  **Доступ к веб-интерфейсу:** Откройте веб-браузер на компьютере или мобильном устройстве и перейдите по IP-адресу ESP32-CAM.
4.  **Управление роботом:**
    *   **Запуск трансляции:** Нажмите кнопку "Start Stream" для начала трансляции видео.
    *   **Режим управления:** Выберите режим "Joystick" или "Sliders" с помощью кнопки "Control Mode".
    *   **Управление джойстиком:** Используйте виртуальный джойстик на экране для управления движением робота (вперед, назад, влево, вправо).
    *   **Управление ползунками:** В режиме ползунков используйте левые и правые вертикальные ползунки для независимой настройки скорости левого и правого моторов.
    *   **Разрешение:** Изменяйте разрешение видео с помощью выпадающего списка в панели настроек. Доступны различные разрешения от QQVGA до UXGA.
    *   **Управление светодиодом:** Регулируйте яркость встроенного светодиода с помощью ползунка в панели настроек (0-100%).
    *   **Bluetooth-управление:** Включите управление по Bluetooth, нажав кнопку "Bluetooth". Интерфейс будет отображать статус подключения и автоматически пытаться подключиться к настроенному Bluetooth-джойстику.
    *   **Полноэкранный режим:** Включите или выключите полноэкранный режим с помощью кнопки "⛶".

## Настройка и расширение

Этот проект предоставляет прочную основу для дальнейшей разработки и настройки. Вот несколько идей:

*   **Добавление датчиков:** Интегрируйте датчики, например, ультразвуковые для обнаружения препятствий, датчики линии для слежения за линией или ИМУ для определения ориентации.
*   **Реализация сложных алгоритмов управления:** Разработайте более продвинутые алгоритмы для автономной навигации, планирования маршрутов или отслеживания объектов.
*   **Улучшение веб-интерфейса:** Расширьте веб-интерфейс дополнительными функциями, такими как отображение данных с датчиков, добавление дополнительных элементов управления или индивидуальная настройка интерфейса.
*   **Передача телеметрии:** Отправляйте телеметрические данные (например, напряжение батареи, ток мотора, показания датчиков) обратно в веб-интерфейс для мониторинга и диагностики.
*   **Обновления OTA:** Реализуйте обновления прошивки по воздуху (OTA), чтобы легко обновлять прошивку ESP32-CAM без физического доступа.
